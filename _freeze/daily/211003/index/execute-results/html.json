{
  "hash": "8ed77b16a7de82df6c1520a49c7d5c29",
  "result": {
    "markdown": "---\ntitle: 'unnest() : Creates a list-column of data frames'\ndate: '2022-10-03'\ncategories: ['tidyr']\ndescription: '중첩된 데이터프레임을 풀 때'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Today Function : unnest\n\n![](logo.png){width=\"25%\"}\n\n오늘의 함수는 tidyr 패키지의 `unnest()` 함수입니다. <br/>\n\n`unnest()` 함수는 중첩된 데이터프레임을 풀 때 사용합니다.\n\n<br/>\n\n### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunnest(\n  data,\n  cols,\n  ...,\n  keep_empty = FALSE,\n  ptype = NULL,\n  names_sep = NULL,\n  names_repair = \"check_unique\",\n  .drop = deprecated(),\n  .id = deprecated(),\n  .sep = deprecated(),\n  .preserve = deprecated()\n)\n```\n:::\n\n\n<br/>\n\n### Argument\n\n**data** : data.frame, tibble을 넣을 수 있습니다. <br/> \n**col** : 중첩된 상태를 해제할 칼럼을 입력합니다. tidy-select expression을 활용해 선택 가능합니다. <br/> \n**keep_empty** : 기본적으로 `unnest()` 함수는 각 요소별로 하나의 출력 행을 가져옵니다. `NULL`값이나 비어있는 경우엔 해당 행이 출력에서 삭제됩니다. 모든 행을 출력하려면 `keep_empty = TRUE`로 표시해야 합니다. <br/>\n**name_sep** : 풀어지는 칼럼의 이름을 정합니다. NULL(기본값)일 경우엔 기존 이름이 그래도 유지됩니다. <br/> \n**names_repair** : 출력되는 데이터프레임에 유효한 이름이 있는지 확인하는 데 사용합니다.\n\n<br/>\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# tibble 함수를 통해 중첩된 tibble을 만들어보겠습니다.\ndf1 <- tibble(\n  x = 1:3,\n  y = list(\n    NULL,\n    tibble(a = 1, b = 2),\n    tibble(a = 1:3, b = 3:1)\n  )\n)\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      x y               \n  <int> <list>          \n1     1 <NULL>          \n2     2 <tibble [1 × 2]>\n3     3 <tibble [3 × 2]>\n```\n:::\n\n```{.r .cell-code}\n# unnest 함수를 통해 중첩된 tibble을 unnest 해보겠습니다.\ndf1 |> unnest(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 3\n      x     a     b\n  <int> <dbl> <dbl>\n1     2     1     2\n2     3     1     3\n3     3     2     2\n4     3     3     1\n```\n:::\n\n```{.r .cell-code}\n# keep_empty = TRUE로 처리할 경우 NULL값이 들어있던 1행도 출력됩니다.\ndf1 |> unnest(y, keep_empty = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n      x     a     b\n  <int> <dbl> <dbl>\n1     1    NA    NA\n2     2     1     2\n3     3     1     3\n4     3     2     2\n5     3     3     1\n```\n:::\n:::\n\n\n<br/>\n\n### names\n\n이번에는 `unnest()` 함수를 통해 중첩을 푸는 과정에서 칼럼의 이름이 어떻게 결정되는지 확인해보겠습니다. `palmerpenguins` 패키지에 있는 펭귄 데이터를 불러와 종별로 총 4가지의 데이터(펭귄의 부리 길이, 깊이, 물갈퀴 길이, 몸무게)의 분위값을 정리해보겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n\npenguins |> \n  select(c(species, bill_depth_mm, bill_length_mm, flipper_length_mm, body_mass_g)) |>\n  group_by(species) |>\n  summarise_all(.funs = function(x) list(enframe(\n    quantile(x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE))))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  species   bill_depth_mm    bill_length_mm   flipper_length_mm body_mass_g     \n  <fct>     <list>           <list>           <list>            <list>          \n1 Adelie    <tibble [3 × 2]> <tibble [3 × 2]> <tibble [3 × 2]>  <tibble [3 × 2]>\n2 Chinstrap <tibble [3 × 2]> <tibble [3 × 2]> <tibble [3 × 2]>  <tibble [3 × 2]>\n3 Gentoo    <tibble [3 × 2]> <tibble [3 × 2]> <tibble [3 × 2]>  <tibble [3 × 2]>\n```\n:::\n:::\n\n\n펭귄 종 별로 4가지 데이터에 대한 분위값이 각각 tibble 형태로 담겨 있습니다. 이걸 `unnest()` 함수를 통해 풀어보겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  select(c(species, bill_depth_mm, bill_length_mm, flipper_length_mm, body_mass_g)) |>\n  group_by(species) |>\n  summarise_all(.funs = function(x) list(enframe(\n    quantile(x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)))) |>\n  unnest()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 9\n  species   name  value name1 value1 name2 value2 name3 value3\n  <fct>     <chr> <dbl> <chr>  <dbl> <chr>  <dbl> <chr>  <dbl>\n1 Adelie    25%    17.5 25%     36.8 25%      186 25%    3350 \n2 Adelie    50%    18.4 50%     38.8 50%      190 50%    3700 \n3 Adelie    75%    19   75%     40.8 75%      195 75%    4000 \n4 Chinstrap 25%    17.5 25%     46.3 25%      191 25%    3488.\n5 Chinstrap 50%    18.4 50%     49.6 50%      196 50%    3700 \n6 Chinstrap 75%    19.4 75%     51.1 75%      201 75%    3950 \n7 Gentoo    25%    14.2 25%     45.3 25%      212 25%    4700 \n8 Gentoo    50%    15   50%     47.3 50%      216 50%    5000 \n9 Gentoo    75%    15.7 75%     49.6 75%      221 75%    5500 \n```\n:::\n:::\n\n\n문제가 발생했습니다. 중첩이 풀린 데이터의 칼럼이 모두 name과 value로 표시되어 구분할 수 없게 되었습니다. 이럴때 사용하는 게 바로 `names_repair`와 `names_sep`입니다. 우선 `names_repair`는 `check_unique`가 기본값으로 되어 있습니다. 겹치는 변수가 없도록 name, name2, name3 같은 고유의 이름을 부여해주죠. 하지만 우리는 각 칼럼이 어떤 데이터인지 이름을 알고 싶습니다. 이럴 땐 `name_sep`을 사용합니다. 구분자를 무엇으로 할 지 설정해주면 해당 칼럼과 구분자를 합쳐서 칼럼명을 부여해줍니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# names_sep = \"_\" 입력\npenguins |> \n  select(c(species, bill_depth_mm, bill_length_mm, flipper_length_mm, body_mass_g)) |>\n  group_by(species) |>\n  summarise_all(.funs = function(x) list(enframe(\n    quantile(x, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)))) |>\n  unnest(names_sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 9\n  species   bill_depth…¹ bill_…² bill_…³ bill_…⁴ flipp…⁵ flipp…⁶ body_…⁷ body_…⁸\n  <fct>     <chr>          <dbl> <chr>     <dbl> <chr>     <dbl> <chr>     <dbl>\n1 Adelie    25%             17.5 25%        36.8 25%         186 25%       3350 \n2 Adelie    50%             18.4 50%        38.8 50%         190 50%       3700 \n3 Adelie    75%             19   75%        40.8 75%         195 75%       4000 \n4 Chinstrap 25%             17.5 25%        46.3 25%         191 25%       3488.\n5 Chinstrap 50%             18.4 50%        49.6 50%         196 50%       3700 \n6 Chinstrap 75%             19.4 75%        51.1 75%         201 75%       3950 \n7 Gentoo    25%             14.2 25%        45.3 25%         212 25%       4700 \n8 Gentoo    50%             15   50%        47.3 50%         216 50%       5000 \n9 Gentoo    75%             15.7 75%        49.6 75%         221 75%       5500 \n# … with abbreviated variable names ¹​bill_depth_mm_name, ²​bill_depth_mm_value,\n#   ³​bill_length_mm_name, ⁴​bill_length_mm_value, ⁵​flipper_length_mm_name,\n#   ⁶​flipper_length_mm_value, ⁷​body_mass_g_name, ⁸​body_mass_g_value\n```\n:::\n:::\n\n\n\n<br/>\n\n### lists of lists\n\n리스트와 리스트가 중첩된 복잡한 데이터프레임을 풀려면 `unnest()` 함수를 두 번 사용하면 됩니다. 복잡하게 중첩된 데이터라면 `hoist()`, `unnest_wider()`, `unnest_longer()` 함수를 사용하면 좋습니다. 위 3개의 함수는 이른바 `rectangling` 작업에 사용되는 함수인데 이 녀석들은 나중에 따로 정리해보겠습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- tibble(\n  a = list(c(\"a\", \"b\"), \"c\"),\n  b = list(1:2, 3),\n  c = c(11, 22)\n)\n\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  a         b             c\n  <list>    <list>    <dbl>\n1 <chr [2]> <int [2]>    11\n2 <chr [1]> <dbl [1]>    22\n```\n:::\n\n```{.r .cell-code}\n# unnest를 이용해 동시에 여러 열의 중첩을 해제할 수 있습니다.\ndf2 |> unnest(c(a, b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  a         b     c\n  <chr> <dbl> <dbl>\n1 a         1    11\n2 b         2    11\n3 c         3    22\n```\n:::\n\n```{.r .cell-code}\n# 단계적으로 중첩을 해제하면 다음과 같은 결과를 얻습니다.\ndf2 |> unnest(a) |> unnest(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  a         b     c\n  <chr> <dbl> <dbl>\n1 a         1    11\n2 a         2    11\n3 b         1    11\n4 b         2    11\n5 c         3    22\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}