{
  "hash": "163c544d8625197938e7318c1ffb1ad0",
  "result": {
    "markdown": "---\ntitle: 'reduce() : Reduce a list to a single value'\ndate: '2022-10-13'\ncategories: ['purrr']\ndescription: '벡터 요소들을 하나의 값으로 결합하고 싶을 때'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Today Function : reduce()\n\n![](logo.png){width=\"25%\"}\n\n오늘의 함수는 purrr 패키지의 `reduce()` 함수입니다. r에서 데이터테이블을 `join`하거나 교집합(`intersect`)을 한다거나 혹은 합집합(`union`)을 하려면 테이블이 2개일 경우에만 가능합니다. 그래서 이런 함수들을 `Two-Table Verbs`라고도 하죠. 그런데 그 이상의 데이터테이블을 가지고 교집합, 합집한 등의 함수를 적용하고 싶다면 어떻게 해야할까요? 그럴 때 사용하는 함수가 바로 `reduce()`입니다. `reduce()`함수는 벡터의 요소를 하나의 값으로 결합, 반복해주는 작업을 실행합니다. 이런 식입니다. 1:3에다가 f라는 함수를 `reduce()`하면 `f(f(1, 2), 3)` 이런 식으로 적용합니다. \n\n<br/>\n\n### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"))\n\nreduce2(.x, .y, .f, ..., .init)\n```\n:::\n\n\n<br/>\n\n### Argument\n\n**.x** : 리스트나 atomic vector가 들어갑니다 <br/> \n**.f** : `reduce()` 함수에서는 `Two-Table Verbs` 함수가, `reduce2()` 함수에는 그 이상의 함수를 사용할 수 있습니다. <br/>\n**.dir** : `reduce`의 방향을 정합니다.\n\n<br/>\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(purrr)\n\n# +로 예를 들어봅시다 1부터 3까지 reduce 함수로 더해봅니다\n1:3 |> reduce(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nreduce(1:3, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# 이번엔 1부터 10까지 곱해보겠습니다\nreduce(1:10, `*`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3628800\n```\n:::\n\n```{.r .cell-code}\n# 10!과 값이 당연히 같습니다\nfactorial(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3628800\n```\n:::\n\n```{.r .cell-code}\n# dplyr 패키지의 join 함수를 reduce 함수와 함께 써보겠습니다\ndfs <- list(\n  age = tibble(name = \"John\", age = 30),\n  sex = tibble(name = c(\"John\", \"Mary\"), sex = c(\"M\", \"F\")),\n  trt = tibble(name = \"Mary\", treatment = \"A\")\n)\ndfs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$age\n# A tibble: 1 × 2\n  name    age\n  <chr> <dbl>\n1 John     30\n\n$sex\n# A tibble: 2 × 2\n  name  sex  \n  <chr> <chr>\n1 John  M    \n2 Mary  F    \n\n$trt\n# A tibble: 1 × 2\n  name  treatment\n  <chr> <chr>    \n1 Mary  A        \n```\n:::\n\n```{.r .cell-code}\ndfs |>reduce(full_join)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  name    age sex   treatment\n  <chr> <dbl> <chr> <chr>    \n1 John     30 M     <NA>     \n2 Mary     NA F     A        \n```\n:::\n:::\n\n\n\n<br/>\n\n#### direction\n\n`reduce`를 적용할 함수 f가 덧셈이나 곱셈처럼 순서가 안 중요한 함수일 수 있지만 대부분의 다른 함수에서는 순서가 중요할 수 있습니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# + 는 방향을 뒤로해도 결과가 달라지지 않습니다. 당연하게도\nreduce(1:3, `+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nreduce(1:3, `+`, .dir = \"backward\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n# 하지만 다른 함수는 순서가 중요합니다\nstr(reduce(1:4, list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ :List of 2\n  ..$ :List of 2\n  .. ..$ : int 1\n  .. ..$ : int 2\n  ..$ : int 3\n $ : int 4\n```\n:::\n\n```{.r .cell-code}\nstr(reduce(1:4, list, .dir = \"backward\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ : int 1\n $ :List of 2\n  ..$ : int 2\n  ..$ :List of 2\n  .. ..$ : int 3\n  .. ..$ : int 4\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}