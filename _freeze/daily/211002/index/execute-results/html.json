{
  "hash": "b1ccbbb3be71695898b88f936daaa4c3",
  "result": {
    "markdown": "---\ntitle: 'nest() : Creates a list-column of data frames'\ndate: '2022-10-02'\ncategories: ['tidyr']\ndescription: '데이터프레임을 중첩시킬 때'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Today Function : nest\n\n![](logo.png){width=\"25%\"}\n\n오늘의 함수는 tidyr 패키지의 `nest()` 함수입니다. <br/> \n`nest()` 함수는 데이터프레임을 중첩시킬 때 사용합니다. <br/>\n중첩(nest)된 데이터프레임은 하나 이상의 열이 리스트인 데이터프레임을 의미합니다. <br/>\n\n<br/>\n\n### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnest(.data, ..., names_sep = NULL, .key = deprecated())\n```\n:::\n\n\n<br/>\n\n### Argument\n\n**.data** : data.frame, tibble을 넣을 수 있습니다. <br/> \n**...** : 중첩될 칼럼을 입력합니다. tidy-select expression을 활용해 선택 가능합니다. <br/> \n**name_sep** : 중첩될 칼럼의 이름을 정합니다. NULL(기본값)일 경우엔 기존 이름이 그래도 유지됩니다. <br/>\n**.key** : 예전 버전의 nest 함수에서 사용한 영역(중첩될 칼럼의 이름 설정)으로 현재 문법에서는 사용하지 않습니다.\n\n<br/>\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# tibble 함수를 통해 중첩된 tibble을 만들어보겠습니다.\n# g와 data라는 2개의 열의 tibble이지만 data 열은 리스트의 형태입니다.\ndf1 <- tibble(\n  g = c(1, 2, 3),\n  data = list(\n    tibble(x = 1, y = 2),\n    tibble(x = 4:5, y = 6:7),\n    tibble(x = 10)\n  )\n)\n\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 1]>\n```\n:::\n\n```{.r .cell-code}\n# 이번엔 nest 함수를 통해 중첩된 tibble을 만들어보겠습니다.\ndf2 <- tribble(\n  ~g, ~x, ~y,\n   1,  1,  2,\n   2,  4,  6,\n   2,  5,  7,\n   3, 10, NA\n)\n\ndf2 |> nest(data = c(x, y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 2]>\n```\n:::\n\n```{.r .cell-code}\n# tidy-select argument를 이용해서 데이터를 선택할 수도 있습니다.\ndf2 |> nest(data = any_of(c(\"x\", \"y\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 2]>\n```\n:::\n\n```{.r .cell-code}\ndf2 |> nest(data = !g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 2]>\n```\n:::\n:::\n\n`nest()` 함수에는 중첩될 변수를 지정합니다. <br/>\n`any_of()`, `starts_with()` 등 tidy_select argument를 이용해서도 지정 가능합니다. <br/> \ng를 기준으로 x와 y를 중첩하는 형태이기때문에 `nest()` 함수에 `c(x, y)`를 입력했습니다. \n\n<br/>\n\n### Grouped data frames\n\n`dplyr::group_by()`를 이용하는 것도 방법입니다. <br/>\n중첩될 변수를 지정하는 것보다 `group_by()`를 이용해 중첩시키는 게 직관적입니다. <br/>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndf2 |> group_by(g) |> nest()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n# Groups:   g [3]\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 2]>\n```\n:::\n\n```{.r .cell-code}\n# 중첩된 데이터프레임을 만들어서 각각의 그룹에 따라 모델을 만들고, 예측 list도 생성할 수 있습니다.\nmtcars_nested <- mtcars |>\n  group_by(cyl) |>\n  nest()\n\nmtcars_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n# Groups:   cyl [3]\n    cyl data              \n  <dbl> <list>            \n1     6 <tibble [7 × 10]> \n2     4 <tibble [11 × 10]>\n3     8 <tibble [14 × 10]>\n```\n:::\n\n```{.r .cell-code}\n# lm 모델 생성\nmtcars_nested <- mtcars_nested |>\n  mutate(model = map(data, function(df) lm(mpg ~ wt, data = df)))\n\nmtcars_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n# Groups:   cyl [3]\n    cyl data               model \n  <dbl> <list>             <list>\n1     6 <tibble [7 × 10]>  <lm>  \n2     4 <tibble [11 × 10]> <lm>  \n3     8 <tibble [14 × 10]> <lm>  \n```\n:::\n\n```{.r .cell-code}\n# 만들어진 모델을 통해 예측값을 계산해봅니다.\nmtcars_nested <- mtcars_nested |>\n  mutate(model = map(model, predict))\n\nmtcars_nested\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n# Groups:   cyl [3]\n    cyl data               model     \n  <dbl> <list>             <list>    \n1     6 <tibble [7 × 10]>  <dbl [7]> \n2     4 <tibble [11 × 10]> <dbl [11]>\n3     8 <tibble [14 × 10]> <dbl [14]>\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}