{
  "hash": "8e2e59276bcb8c8108cd4fd9be455be5",
  "result": {
    "markdown": "---\ntitle: 'pull() : Extract a single column'\ndate: '2022-10-04'\ncategories: ['dplyr']\ndescription: '$ 연산자와 비슷한 함수'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Today Function : pull\n\n![](logo.png){width=\"25%\"}\n\n오늘의 함수는 dplyr 패키지의 `pull()` 함수입니다. <br/> `pull()` 함수는 `$` 연산자와 비슷한 기능을 합니다. <br/> `$` 연산자는 R에서 데이터 객체의 특정 부분을 추출할 때 사용하는데요. <br/> `pull()` 함수는 파이프 연산자 내에서 `$`보다 사용하기 편리하다는 장점이 있습니다.\n\n<br/>\n\n### Usage\n\n\n::: {.cell}\n\n```{.r .cell-code}\npull(.data, var = -1, name = NULL, ...)\n```\n:::\n\n\n<br/>\n\n### Argument\n\n**.data** : data.frame, tibble을 넣을 수 있습니다. 거기에 dbplyr, dtplyr package의 data.table backend도 가능합니다. <br/> **var** : 추출할 변수의 이름을 넣습니다. 숫자도 가능한데 양수는 왼쪽부터 순서, 음수는 오른쪽부터 순서를 나타냅니다. <br/> **name** : 변수 이름을 알 경우엔 name이라는 파라미터를 써도 됩니다.\n\n<br/>\n\n### Value\n\n입력한 데이터와 동일한 사이즈의 vector가 나옵니다.\n\n<br/>\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# mtcars 데이터를 가지고 pull() 함수의 예를 들어보겠습니다.\n# mtcars 데이터의 구조는 이러합니다.\nhead(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n:::\n\n```{.r .cell-code}\n# -1을 입력하면 mtcars 데이터의 맨 오른쪽 칼럼인 carb가 나옵니다\nmtcars |> pull(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2\n```\n:::\n\n```{.r .cell-code}\n# 칼럼 명 'carb'을 바로 써도 같은 결과가 나옵니다\nmtcars |> pull(carb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2\n```\n:::\n:::\n\n\n<br/>\n\n### select vs pull\n\ndplyr에 있는 또다른 비슷한 함수인 select와의 차이점은 뭘까요? 일단 결과 값이 다릅니다. <br/> pull은 단일 열을 벡터로 변환해 결과로 내보냅니다. 반면 select는 하나 이상의 열을 데이터프레임으로 변환하죠.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits <- data.frame(orange = 1:5, lemon = 5:1)\n\n# select를 써서 orange 열(1개의 열)을 가져오면 data.frame이 나옵니다\nfruits |> select(orange) |>str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5 obs. of  1 variable:\n $ orange: int  1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# 이번엔 pull을 이용하면 int value가 들어간 벡터가 나옵니다\nfruits |> pull(orange) |> str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:5] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# data.frame에서 pull과 의미가 동일한 함수 -> .[, \"name\"]\nfruits %>% .[ , \"orange\"] %>% str()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n int [1:5] 1 2 3 4 5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}